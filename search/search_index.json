{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api-reference/","title":"Api reference","text":""},{"location":"api-reference/#configuration","title":"Configuration","text":"<p>The settings below are default values that can be accessed directly from the SimplePath modulescript.</p> <p>Note</p> <p>Changing default settings will only affect agents that don't already have overridden settings.</p> <p>To override settings for a single agent, pass in a dictionary (with a setting as the key) to the constructor and include values in the dictionary to override. See constructor for more info.</p> <p></p>"},{"location":"api-reference/#time_variance","title":"TIME_VARIANCE","text":"<p><code>Settings.TIME_VARIANCE: number</code> [default: 0.07]</p> <p>Represents the minimum time in seconds elapsed between Path.Run calls. The default setting is roughly 14 computations per second. This is necessary to allow the agent the freedom for movement (give the agent some time to reach the next waypoint before computing a new path).</p> <p></p>"},{"location":"api-reference/#comparison_checks","title":"COMPARISON_CHECKS","text":"<p><code>Settings.COMPARISON_CHECKS: number</code> [default: 1]</p> <p>During pathfinding, in the case where the agent is stationary at the same position for 1 + COMPARISON_CHECKS consecutive Path.Run calls, the agent attempts to avoid the obstruction by jumping. This is necessary in order to prevent the agent from being at rest for infinity (unless otherwise moved by an external object).</p> <p></p>"},{"location":"api-reference/#jump_when_stuck","title":"JUMP_WHEN_STUCK","text":"<p><code>Settings.JUMP_WHEN_STUCK: boolean</code> [default: true] [humanoid only]</p> <p><code>Settings.JUMP_WHEN_STUCK</code> is directly dependant on <code>Settings.COMPARISON_CHECKS</code>. If this is false, the agent will not attempt to jump.</p> <p>Warning</p> <p>Overriding this setting to <code>false</code> will prevent the agent from jumping which can cause the agent to remain at rest for infinity. Do not disable this setting without properly handling it using ErrorType.AgentStuck.</p>"},{"location":"api-reference/#errortypes","title":"ErrorTypes","text":"Example<pre><code>Path.Error:Connect(function(errorType)\n    if errorType == SimplePath.ErrorType.ComputationError then\n        --code (1)\n    end\nend)\n</code></pre> <ol> <li>This code block will run whenever there's a ComputationError.</li> </ol> <p>Info</p> <p>Use ErrorTypes to determine the type of error received from the Path.Error event. For additional debug options, see Path.LastError.</p> <p></p>"},{"location":"api-reference/#limitreached","title":"LimitReached","text":"<p><code>ErrorType.LimitReached: ErrorType and string</code></p> <p>The elapsed time between Path.Run calls is less than Settings.TIME_VARIANCE. For stability purposes, this error is invoked after <code>Path:Run()</code> yields for Settings.TIME_VARIANCE.</p> <p>It is recommended to avoid depending on this ErrorType.</p> <p></p>"},{"location":"api-reference/#targetunreachable","title":"TargetUnreachable","text":"<p><code>ErrorType.TargetUnreachable: ErrorType and string</code></p> <p>Target is unreachable.</p> <p></p>"},{"location":"api-reference/#computationerror","title":"ComputationError","text":"<p><code>ErrorType.ComputationError: ErrorType and string</code></p> <p>Path computation failed.</p> <p></p>"},{"location":"api-reference/#agentstuck","title":"AgentStuck","text":"<p><code>ErrorType.AgentStuck: ErrorType and string</code></p> <p>Agent is stuck (possibly due to an obstruction of some kind).</p> <p>Note</p> <p>This is different from Path.Blocked in the sense that it is detected by SimplePath itself when the agent does not move for Settings.COMPARISON_CHECKS + 1 consecutive Path.Run calls.</p>"},{"location":"api-reference/#statustypes","title":"StatusTypes","text":"<p>Read the Path.Status property to get the current Path status.</p> <p></p>"},{"location":"api-reference/#idle","title":"Idle","text":"<p><code>StatusType.Idle: StatusType and string</code></p> <p>Path is in idle state.</p> <p></p>"},{"location":"api-reference/#active","title":"Active","text":"<p><code>StatusType.Active: StatusType and string</code></p> <p>Path is in active state.</p>"},{"location":"api-reference/#static-methods","title":"Static Methods","text":""},{"location":"api-reference/#getnearestcharacter","title":"GetNearestCharacter","text":"<p><code>&lt;model or nil&gt; SimplePath.GetNearestCharacter(fromPosition: Vector3)</code> </p> <p>Returns a <code>model</code> of the nearest character from the provided <code>Vector3</code> position or <code>nil</code> if no character is found.</p>"},{"location":"api-reference/#path","title":"Path","text":""},{"location":"api-reference/#constructor","title":"Constructor","text":"<p><code>&lt;Path&gt; SimplePath.new(agent: model, agentParameters: Dictionary or nil, override: Dictionary or nil)</code></p> <p>Creates a new Path object using the <code>agent</code> with optional <code>agentParameters</code>. Pass in <code>override</code> as a dictionary that includes a setting and its overridden value.</p> <p>Note</p> <p><code>SimplePath.new()</code> is a constructor that creates a new Path and it should only be created once per agent. You can call <code>Path:Run()</code> on the same Path object multiple times without having to create a new Path every time you need to do pathfinding.</p> <p>Info</p> <p>Use agent parameters for custom characters to compute the best path. Find out more about agent parameters and how to use them at Roblox Developer Hub.</p> <p>Refine the path computation further by using pathfinding modifiers. To use this feature with SimplePath, Simply include modifier data in <code>agentParameters</code> normally. Find out more about pathfinding modifiers at Roblox Developer Hub.</p>"},{"location":"api-reference/#properties","title":"Properties","text":""},{"location":"api-reference/#visualize","title":"Visualize","text":"<p><code>Path.Visualize: boolean</code> [default: false]</p> <p>Set this property to <code>true</code> before the first <code>Path:Run()</code> to visualize waypoints.</p> <p></p>"},{"location":"api-reference/#status","title":"Status","text":"<p><code>Path.Status: SimplePath.StatusType</code> [readonly]</p> <p>Returns the current StatusType of Path.</p> <p>Note</p> <p>This will return <code>SimplePath.StatusType.Idle</code> always for non-humanoids since pathfinding for a non-humanoid is meant to be handled manually.</p> <p></p>"},{"location":"api-reference/#lasterror","title":"LastError","text":"<p><code>Path.LastError: SimplePath.ErrorType</code> [readonly]</p> <p>Returns the last ErrorType.</p>"},{"location":"api-reference/#methods","title":"Methods","text":""},{"location":"api-reference/#run","title":"Run","text":"<p><code>&lt;boolean&gt; Path:Run(target: Vector3 or BasePart)</code></p> <p>This method returns <code>true</code> if the computation was successful. If it returns <code>false</code>, the Path.Error event is fired with a ComputationError. This method automatically yields if the elapsed time between consecutive calls is less than Settings.TIME_VARIANCE.</p> <p></p>"},{"location":"api-reference/#stop","title":"Stop","text":"<p><code>&lt;void&gt; Path:Stop()</code></p> <p>Stops the navigation of the current Path if Path.Status is in an active state and fires the Path.Stopped event.</p> <p>Note</p> <p>This method cannot be used for non-humanoids since pathfinding is meant to be handled manually.</p> <p></p>"},{"location":"api-reference/#destroy","title":"Destroy","text":"<p><code>&lt;void&gt; Path:Destroy()</code></p> <p>Destroy Path.</p>"},{"location":"api-reference/#events","title":"Events","text":""},{"location":"api-reference/#reached","title":"Reached","text":"<p><code>&lt;RBXScriptSignal&gt; Path.Reached(agent: model, finalWaypoint: PathWaypoint)</code></p> <p>This event is fired after the <code>agent</code> reaches its target and returns the final <code>PathWaypoint</code>.</p> <p>Info</p> <p>Find out more about <code>PathWaypoint</code> at Roblox Developer Hub.</p> <p></p>"},{"location":"api-reference/#waypointreached","title":"WaypointReached","text":"<p><code>&lt;RBXScriptSignal&gt; Path.WaypointReached(agent: model, last: PathWaypoint, next: PathWaypoint)</code></p> <p>This event is fired every time the next <code>PathWaypoint</code> is reached.</p> <p>Note</p> <p>Make use of this event when pathfinding for non-humanoids.</p> <p>Warning</p> <p>For stabililty purposes, this event will not fire for the second-last waypoint when used for Humanoids.</p> <p></p>"},{"location":"api-reference/#blocked","title":"Blocked","text":"<p><code>&lt;RBXScriptSignal&gt; Path.Blocked(agent: model, blocked: PathWaypoint)</code></p> <p><code>blocked</code> is a <code>PathWaypoint</code> such that: <code>currentWaypoint.Index &lt;= blocked.Index &lt;= currentWaypoint.Index + 1</code>.</p> <p></p>"},{"location":"api-reference/#error","title":"Error","text":"<p><code>&lt;RBXScriptSignal&gt; Path.Error(error: ErrorType and string)</code></p> <p>Fires when an error from any of the ErrorTypes occurs.</p> <p></p>"},{"location":"api-reference/#stopped","title":"Stopped","text":"<p><code>&lt;RBXScriptSignal&gt; Path.Stopped(agent: model)</code></p> <p>Fires after <code>Path:Stop()</code> is called.</p> <p>Note</p> <p>Just like the Path.Stop method, this event should only be used for humanoids.</p>"},{"location":"api-reference/Classes/messages/","title":"Messages Class","text":"<p>use with Notification Service</p>"},{"location":"api-reference/Classes/messages/#constructor","title":"Constructor","text":"<p><code>&lt;Message&gt; Messages.new()</code></p>"},{"location":"api-reference/Classes/messages/#public-functions","title":"Public Functions","text":""},{"location":"api-reference/Classes/messages/#settarget","title":"SetTarget","text":"<p><code>&lt;void&gt; Messages:SetTarget(Target: Player)</code></p>"},{"location":"api-reference/Classes/messages/#addlines","title":"AddLines","text":"<p><code>&lt;void&gt;  Messages:AddLines(text: SmartText2)</code></p> <p></p>"},{"location":"api-reference/Classes/quests/","title":"Quest Class","text":"<p>Use with Quest Service</p>"},{"location":"api-reference/Classes/quests/#constructor","title":"Constructor","text":"<p><code>&lt;Quest&gt; Quest.new(Player: Player, Info: table)</code></p> <p>Creates a new quest instance.</p> <ul> <li>Parameters:</li> <li><code>Player</code> (Player): The player associated with the quest.</li> <li><code>Info</code> (table): Information about the quest, including its name and type.</li> </ul>"},{"location":"api-reference/Classes/quests/#public-methods","title":"Public Methods","text":""},{"location":"api-reference/Classes/quests/#init","title":"Init","text":"<p><code>&lt;void&gt; Quest:Init(...)</code></p> <p>Initializes the quest.</p>"},{"location":"api-reference/Classes/quests/#start","title":"Start","text":"<p><code>&lt;void&gt; Quest:Start(...)</code></p> <p>Starts the quest.</p>"},{"location":"api-reference/Classes/quests/#process","title":"Process","text":"<p><code>&lt;void&gt; Quest:Process(...)</code></p> <p>Processes the quest.</p>"},{"location":"api-reference/Classes/quests/#completed","title":"Completed","text":"<p><code>&lt;void&gt; Quest:Completed(...)</code></p> <p>Marks the quest as completed.</p>"},{"location":"api-reference/Classes/quests/#cancel","title":"Cancel","text":"<p><code>&lt;void&gt; Quest:Cancel(...)</code></p> <p>Cancels the quest.</p>"},{"location":"api-reference/Classes/quests/#changestate","title":"ChangeState","text":"<p><code>&lt;void&gt; Quest:ChangeState(State: string)</code></p> <p>Changes the state of the quest.</p> <ul> <li>Parameters:</li> <li><code>State</code> (string): The new state for the quest.</li> </ul>"},{"location":"api-reference/Classes/quests/#changestatus","title":"ChangeStatus","text":"<p><code>&lt;void&gt; Quest:ChangeStatus(Status: string)</code></p> <p>Changes the status of the quest.</p> <ul> <li>Parameters:</li> <li><code>Status</code> (string): The new status for the quest.</li> </ul>"},{"location":"api-reference/Classes/quests/#editquesttask","title":"EditQuestTask","text":"<p><code>&lt;void&gt; Quest:EditQuestTask(Info: QuestTaskUI)</code></p> <p>Edits the quest task.</p> <ul> <li>Parameters:</li> <li><code>Info</code> (QuestTaskUI): Information about the quest task.</li> </ul>"},{"location":"api-reference/Classes/quests/#updatequesttask","title":"UpdateQuestTask","text":"<p><code>&lt;void&gt; Quest:UpdateQuestTask()</code></p> <p>Updates the quest task and informs the client.</p>"},{"location":"api-reference/Services/monsters-service/","title":"Monsters Service Documentation","text":"<p>The <code>MonstersService</code> module provides functions for spawning and managing monsters.</p>"},{"location":"api-reference/Services/monsters-service/#configuration","title":"Configuration","text":""},{"location":"api-reference/Services/monsters-service/#respawn","title":"Respawn","text":"<p><code>Respawn : boolean?</code> [default: true] </p> <p>Determines whether the monster should respawn after dying.</p>"},{"location":"api-reference/Services/monsters-service/#reward","title":"Reward","text":"<p><code>Reward : boolean?</code> [default: true]</p> <p>Determines whether the monster should provide rewards upon death.</p>"},{"location":"api-reference/Services/monsters-service/#ai","title":"AI","text":"<p><code>AI : Name? | ModuleScript?</code> [default: Monster_Config]</p> <p>Specifies the AI to be used for the spawned monster. It can be either the name of the AI or a ModuleScript.</p>"},{"location":"api-reference/Services/monsters-service/#btree","title":"BTree","text":"<p><code>BTree : Name? | Folder?</code> [default: Monster_Config]</p> <p>Specifies the behavior tree (BTree) for the monster. It can be either the name of the BTree or a folder containing the BTree.</p>"},{"location":"api-reference/Services/monsters-service/#waypoints","title":"Waypoints","text":"<p><code>Waypoints : Folder?</code> [default: nil]</p> <p>Specifies the waypoints folder for the monster's movement.</p> <p></p>"},{"location":"api-reference/Services/monsters-service/#events","title":"Events","text":""},{"location":"api-reference/Services/monsters-service/#spawned","title":"Spawned","text":"<p><code>&lt;RBXScriptSignal&gt; MonstersService.Spawned(Monster: Table)</code></p> <p>Fired when monsters are spawned in the game.</p> <p></p>"},{"location":"api-reference/Services/monsters-service/#died","title":"Died","text":"<p><code>&lt;RBXScriptSignal&gt; MonstersService.Died(Monster: Table)</code></p> <p>Fired when monsters die in the game.</p> <p></p>"},{"location":"api-reference/Services/monsters-service/#functions","title":"Functions","text":""},{"location":"api-reference/Services/monsters-service/#spawn","title":"Spawn","text":"<p><code>&lt;Table&gt; MonstersService.Spawn(Name: Name, Position: Vector3? | CFrame?, Config : SpawnConfig?)</code></p> <p>Spawns a monster with the specified parameters.</p> <ul> <li>Parameters:</li> <li><code>Name</code> (string): The name of the monster to spawn.</li> <li><code>Position</code> (Vector3|CFrame): The position where the monster will be spawned.</li> <li> <p><code>Config</code> (Spawn_Config): Optional configuration for spawning the monster.</p> </li> <li> <p>Returns:</p> </li> <li>table: A table containing information about the spawned monster.</li> </ul> <p></p>"},{"location":"api-reference/Services/monsters-service/#despawn","title":"Despawn","text":"<p><code>&lt;void&gt; MonstersService.Despawn(UID: string)</code></p> <p>Despawns a monster with the given UID.</p> <ul> <li>Parameters:</li> <li><code>UID</code> (string): The unique identifier of the monster to despawn.</li> </ul> <p></p>"},{"location":"api-reference/Services/monsters-service/#getmonsterinfo","title":"GetMonsterInfo","text":"<p><code>&lt;Table&gt; MonstersService:GetMonsterInfo(Name: string)</code></p> <p>Retrieves information about a specific monster by its name.</p> <ul> <li>Parameters:</li> <li> <p><code>Name</code> (string): The name of the monster.</p> </li> <li> <p>Returns:</p> </li> <li>table|null: A table containing information about the monster, or <code>null</code> if not found.</li> </ul> <p></p>"},{"location":"api-reference/Services/monsters-service/#getmonsterbyid","title":"GetMonsterById","text":"<p><code>&lt;Table&gt; MonstersService:GetMonsterById(UID: string)</code></p> <p>Retrieves information about a specific monster by its UID.</p> <ul> <li>Parameters:</li> <li> <p><code>UID</code> (number): The unique identifier of the monster.</p> </li> <li> <p>Returns:</p> </li> <li>table|null: A table containing information about the monster, or <code>null</code> if not found.</li> </ul>"},{"location":"api-reference/Services/notification-service/","title":"Notification System Documentation","text":"<p>The Notification System provides a mechanism for sending messages to clients.</p>"},{"location":"api-reference/Services/notification-service/#modules","title":"Modules","text":""},{"location":"api-reference/Services/notification-service/#server-module","title":"Server Module","text":"<p>Responsible for handling server-side functionality.</p> <ul> <li><code>Server.Messages</code>: Module for managing server messages. Messages Class</li> <li><code>Server.Text</code>: Module for working with SmartText2.</li> </ul>"},{"location":"api-reference/Services/notification-service/#client-functions","title":"Client Functions","text":"<p>Responsible for handling client-side functionality.</p>"},{"location":"api-reference/Services/notification-service/#listen","title":"Listen","text":"<p><code>&lt;RBXScriptConnection&gt; NotificationService.Listen(Func: function)</code></p> <p>Connects a function to the client event to listen for notifications.</p>"},{"location":"api-reference/Services/notification-service/#server-functions","title":"Server Functions","text":""},{"location":"api-reference/Services/notification-service/#notify","title":"Notify","text":"<p><code>&lt;void&gt; NotificationService.Notify(Target: Any, Text: string)</code></p> <p>Notifies clients with a text message.</p>"},{"location":"api-reference/Services/notification-service/#sendmessages","title":"SendMessages","text":"<p><code>&lt;void&gt; NotificationService.SendMessages(Messages: Messages)</code></p> <p>Sends multiple messages to specified target(s) with Messages Class.</p>"},{"location":"api-reference/Services/notification-service/#_send","title":"_send","text":"<p><code>&lt;void&gt; NotificationService._send(Target: Any, data: Any)</code></p> <p>Sends notifications to specified target(s).</p> <ul> <li>If <code>Target</code> is <code>\"All\"</code>, sends the notification to all clients.</li> <li>If <code>Target</code> is a table of players, sends the notification to each player in the table.</li> <li>If <code>Target</code> is a specific player, sends the notification only to that player.</li> </ul>"},{"location":"api-reference/Services/quests-service/","title":"Quest Service Documentation","text":"<p>The <code>QuestService</code> module provides functions for managing quests.</p>"},{"location":"api-reference/Services/quests-service/#functions","title":"Functions","text":""},{"location":"api-reference/Services/quests-service/#givequest","title":"giveQuest","text":"<p><code>&lt;void&gt; QuestService.giveQuest(player: Player, quest: QuestInfo)</code></p> <p>Gives a quest to a player.</p> <ul> <li>Parameters:</li> <li><code>player</code> (Player): The player to whom the quest will be given.</li> <li><code>quest</code> (QuestClass): new class of quest.</li> </ul>"},{"location":"api-reference/Services/quests-service/#cancelquest","title":"cancelQuest","text":"<p><code>&lt;void&gt; QuestService.cancelQuest(player: Player, tier: string)</code></p> <p>Cancels a quest for a player.</p> <ul> <li>Parameters:</li> <li><code>player</code> (Player): The player for whom the quest will be canceled.</li> <li><code>tier</code> (string): The tier or type of the quest to cancel.</li> </ul>"},{"location":"api-reference/Services/quests-service/#clearcache","title":"clearCache","text":"<p><code>&lt;void&gt; QuestService.clearCache(player: Player)</code></p> <p>Clears the quest cache for a player.</p> <ul> <li>Parameters:</li> <li><code>player</code> (Player): The player for whom the quest cache will be cleared.</li> </ul>"},{"location":"api-reference/Services/quests-service/#register","title":"register","text":"<p><code>&lt;void&gt; QuestService.register(player: Player)</code></p> <p>Registers a player for quest tracking.</p> <ul> <li>Parameters:</li> <li><code>player</code> (Player): The player to register.</li> </ul>"},{"location":"api-reference/Services/quests-service/#getplayerquests","title":"GetPlayerQuests","text":"<p><code>&lt;table&gt; QuestService.GetPlayerQuests(userId: number)</code></p> <p>Retrieves a table containing information about a player's quests.</p> <ul> <li>Parameters:</li> <li> <p><code>userId</code> (number): The unique identifier of the player.</p> </li> <li> <p>Returns:</p> </li> <li>table: A table containing information about the player's quests.</li> </ul>"},{"location":"api-reference/Services/reward-service/","title":"Reward Service Documentation","text":"<p>The <code>RewardService</code> module provides functions for handling rewards related to quests and defeating monsters.</p>"},{"location":"api-reference/Services/reward-service/#functions","title":"Functions","text":""},{"location":"api-reference/Services/reward-service/#questreward","title":"questReward","text":"<p><code>&lt;void&gt; RewardService.questReward(player: Player, reward: table)</code></p> <p>Grants rewards to a player for completing quests.</p> <ul> <li>Parameters:</li> <li><code>player</code> (Player): The player to whom the rewards will be granted.</li> <li><code>reward</code> (table): The reward information, including leaderboard points.</li> </ul>"},{"location":"api-reference/Services/reward-service/#monsterreward","title":"monsterReward","text":"<p><code>&lt;void&gt; RewardService.monsterReward(name: string, reward: table, data: table)</code></p> <p>Grants rewards to a player for defeating monsters.</p> <ul> <li>Parameters:</li> <li><code>name</code> (string): The name or identifier of the monster.</li> <li><code>reward</code> (table): The reward information, including leaderboard points.</li> <li><code>data</code> (table): Additional data related to the defeated monster.</li> </ul>"},{"location":"api-reference/Services/reward-service/#locals-functions","title":"Locals Functions","text":""},{"location":"api-reference/Services/reward-service/#slottable","title":"slotTable","text":"<p><code>&lt;table&gt; slotTable(t: table)</code></p> <p>Sorts a table of player data by values.</p> <ul> <li>Parameters:</li> <li> <p><code>t</code> (table): The table to be sorted.</p> </li> <li> <p>Returns:</p> </li> <li>table: A sorted table of player data.</li> </ul>"},{"location":"examples/monsters/","title":"Create Monsters Example","text":"<p>1.Create a folder with the structure as shown below.</p> <p></p> <p>2.Create BTree folder with plugin and edit.</p> <p></p> <p></p> <p>3.Write AI modules</p> <p></p> <p>4.Save Animations</p> <p></p> <p>5.Config Monsters in Config Module</p> <p></p> <p>6.Spawn monster with monsterservice</p> <pre><code>local ServerStorage = game:GetService(\"ServerStorage\")\n\nlocal Monsters_Service = require(ServerStorage:WaitForChild(\"Scripts\").Utilities.Services.MonstersService)\nlocal Position = Vector3.new(10,20,30)\n\nlocal Spawn_Config = {\n    Respawn = true;\n    Reward = true;\n    Waypoints = workspace.SlineWayPoint -- Folder\n}\n\nMonsters_Service.Spawn(\"Cute Slime 01\", Position, Spawn_Config)\n</code></pre>"},{"location":"examples/notification/","title":"Notification Examples","text":""},{"location":"examples/notification/#notification-with-messages","title":"Notification with messages","text":"<p>for more text formatting see SmartText2 <pre><code>local Player = game.PLayers.tawan30300\nlocal message = NotificationService.Messages.new()\n\nmessage:SetTarget(Player)\nmessage:AddLines(\"Quest has been completed!!\"):ColorHEX(\"#26de57\")\nmessage:AddLines(\"You Received 500 Exp and 150 Coins.\"):ColorHEX(\"#ffdd00\")\nNotificationService.SendMessages(message)\n</code></pre></p>"},{"location":"examples/notification/#simple-notification","title":"Simple Notification","text":"<pre><code>local Player = game.PLayers.tawan30300\nlocal text1 = \"Test123\"\nlocal text2 = SmartText2.new(\"TEst123\"):ColorHEX(\"#ffdd00\")\n\nNotificationService.Notify(Player, text1)\nNotificationService.Notify(Player, text2)\n</code></pre>"},{"location":"examples/quest/","title":"Quests Examples","text":""},{"location":"examples/quest/#quest-info-templete","title":"Quest Info Templete","text":"<pre><code>local Quest = {\n    Name = \"\";\n    Type = \"\";\n}\n\n\n\nfunction Quest:_init(args)\n\nend\n\nfunction Quest:_start(args)\n\nend\n\nfunction Quest:_process(args)\n\nend\n\nfunction Quest:_completed(args)\n\nend\n\nfunction Quest:_cancel(args)\n\nend\n\nfunction Quest.new(Info)\n    local self = table.clone(Quest)\n\n    for i,v in Info do\n        self[i] = v\n    end\n\n    return self\nend\n\nreturn Quest\n</code></pre>"},{"location":"examples/quest/#write-quest-info-module","title":"Write Quest Info Module","text":"<pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal ServerStorage = game:GetService(\"ServerStorage\")\n\nlocal Shared_Services = ReplicatedStorage:WaitForChild(\"Services\")\nlocal NotificationService = require(Shared_Services.NotificationService)\n\nlocal Shared_Modules = ReplicatedStorage:WaitForChild(\"Shared\")\nlocal Janitor = require(Shared_Modules:WaitForChild(\"Janitor\"))\n\nlocal MonstersService = require(ServerStorage:WaitForChild(\"Scripts\").Utilities.Services.MonstersService)\n\nlocal Quest = {\n    Name = \"Defeat_Monster\";\n    Type = \"Defeat_Monster\";\n    Amount = 0;\n}\n\nexport type QuestInfo = {\n    Goal : number;\n    Target : string;\n}\n\nfunction Quest:_init(args)\n    local Info = MonstersService:GetMonsterInfo(self.Target)\n\n    if not (Info) then\n        return error(\"Not Found Monster\")\n    end\n\n    self.Modules.Janitor = Janitor.new()\n\n    return true\nend\n\nfunction Quest:_start(args)\n    self:EditQuestTask( {\n        Title = \"Defeat Monster\";\n        Description = \"Defeat 0/\" .. self.Goal .. \" of \" .. self.Target;\n        Reward = \"-\";\n        Enabled = true;\n    })\n\n    self.Modules.Janitor:Add(MonstersService.Died:Connect(function(monster)\n        if monster.Name == self.Target then\n            self:Process({\n                State = \"Defeat\"\n            })\n        end\n    end), \"Disconnect\", \"Monster\")\nend\n\nfunction Quest:_process(args)\n    if args.State == \"Defeat\" then\n        self.Amount += 1\n\n        self:EditQuestTask( {\n            Title = \"Defeat Monster\";\n            Description = \"Defeat \".. self.Amount ..\"/\" .. self.Goal .. \" of \" .. self.Target;\n            Reward = \"-\";\n            Enabled = true;\n        })\n    end\n\n    if self.Amount == self.Goal then\n        self:Completed()\n    end\nend\n\nfunction Quest:_completed(args)\n    local message = NotificationService.Messages.new()\n\n    message:SetTarget(self.Player)\n    message:AddLines(\"Quest has been completed!!\"):ColorHEX(\"#26de57\")\n    NotificationService.SendMessages(message)\n\n    self:EditQuestTask({\n        Enabled = false;\n    })\n\n    self.Modules.Janitor:Cleanup()\nend\n\nfunction Quest:_cancel(args)\n    self.Modules.Janitor:Cleanup()\nend\n\nfunction Quest.new(Info: QuestInfo)\n    assert(Info[\"Target\"], \"Error: Target is nil\")\n    assert(Info[\"Goal\"], \"Error: Goal is nil\")\n\n    local self = table.clone(Quest)\n\n    for i,v in Info do\n        self[i] = v\n    end\n\n    return self\nend\n\nreturn Quest\n</code></pre>"},{"location":"examples/quest/#give-quest","title":"Give Quest","text":"<pre><code>local ServerStorage = game:GetService(\"ServerStorage\")\nlocal Players = game:GetService(\"Players\")\n\n-- Require the Quest Service module\nlocal QuestService = require(ServerStorage:WaitForChild(\"Scripts\").Utilities.Services.QuestService)\n\n-- Connect to the PlayerAdded event to register players and give them a quest\nPlayers.PlayerAdded:Connect(function(player: Player)\n    -- Register the player for quest tracking\n    QuestService.register(player)\n\n    -- Create a quest information object for defeating monsters\n    local Info = require(ServerStorage:WaitForChild(\"Quests\").Preset.Defeat_Monster).new({\n        Target = \"Cute Slime 01\";\n        Goal = 5;\n    })\n\n    -- Give the player the quest\n    QuestService.giveQuest(player, Info)\nend)\n\n-- Connect to the PlayerRemoving event to clear the quest cache when a player leaves\nPlayers.PlayerRemoving:Connect(function(player)\n    QuestService.clearCache(player)\nend)\n</code></pre>"}]}